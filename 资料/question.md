## 网络和并发

### HTTP1.0/1.1/2.0 在并发请求上主要的区别是什么？

- HTTP1.0
  - 每个TCP连接只能发送一个请求，当服务器响应后就会关闭这个连接，下一次请求需要再次建立TCP连接

- HTTP1.1
  - 默认采用持久连接，TCP，请求头Connection: keep-alive 关闭Connection: close
  - 管道机制，在同一个TCP连接里，允许多个请求同时发送，所有的数据通信是有顺序的 对头阻塞

- HTTP2.0
  - 双工模式，服务器也能同时处理多个请求，解决了对头阻塞的问题
  - 多路复用， 没有次序的概念了
  - 服务器推送

### HTTP/1.1的长连接和2.0的多路复用的区别？

- 1.1：同一个时间一个TCP连接只能处理一个请求，采用一问一答的形式，上一个请求响应后才能处理下一个请求。chrome支持最大6个TCP连接
- 2.0：同域名上的所有通信都在单个连接上完成，单个连接上可以并行交错的进行请求和响应

### 为什么HTTP/1.1不能实现多路复用呢？

- 传输数据的方式不同：HTTP/2.0是基于二进制帧的协议，HTTP/1.1是基于文本分割解析的协议
- 1.1的报文结构里，服务器需要不断的读入字节，直到遇到换行符，处理的顺序是串行的
```http
GET / HTTP1.1
Accept:
host:
referer:

POST / HTTP 1.1
```
- 2.0以帧为最小的数据单位，每个帧都会有标识自己属于哪个流，多个帧组成一个流
  - 多路复用，其实就是一个TCP里存在多条流

### 前端代码里有什么方式能控制最大并发量吗？

### 如果任务有优先级的概念，需要允许高优任务的插入呢？

## 内存管理

### 了解js中的内存管理吗？什么情况会导致内存泄漏呢？

1. 内存的生命周期

- 内存分配：声明变量、函数、对象的时候
- 内存使用：读写内存，使用变量、函数等
- 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

2. js中内存的分配
```js
const n = 123;
const a = 'sss';
```

3. js内存的使用
```js
const a = '123';
console.log(a); // 使用
```

4. js中的垃圾回收机制

垃圾回收的算法主要依赖于引用的概念

- 引用计数法
  - 看一个对象是否有指向他的引用，如果没有其他对象指向他，说明当前这个对象不再被需要了
  - 循环引用！！！
  - 如果两个对象相互引用，尽管他们不再被使用，但是引用计数无法识别，导致内存泄漏
- 标记清除法
  - 将“不再使用的对象”定义为“无法到达的对象”
  - 从根部js的全局对象出发，定时扫描内存中的对象，凡是无法从根部无法到达的对象，就会被标记为不再使用，稍后进行回收

  * 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
  * 将从根部出发能够触及到的对象标记清除
  * 剩下的还有标记的变量被视为准备删除的变量
  * 垃圾收集器销毁带有标记的值，回收内存空间

5. 常见的内存泄漏
- 全局变量：绑定在window上的变量
- 未被清除的定时器和回调函数 setTimeout setInterval
- 闭包：一个函数访问另一个函数并返回函数内部声明的变量
- DOM引用

6. 避免内存泄漏
- 尽量减少全局变量
- 使用完数据后，及时解除引用，变为null
- 避免死循环等持续执行的代码

### 实现一个sizeof函数，接收一个对象参数，计算传入的对象所占的Bytes数

### 基本类型占用的字节数（Bytes）null undefined boolean number string symbol bigint










## 贪心算法
