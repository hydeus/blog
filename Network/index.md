## TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）

  指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇

    - IP（Internet Protocol，网际互联协议）
    - TCP（Transmission Control Protocol，传输控制协议）

## HTTP(HyperText Transfer Protocol，超文本传输协议)

  #### HTTP1.0
    - 无状态、无连接

  #### HTTP1.1
    - 持久连接（connection: keep-alive）
    - 请求管道化
    - 增加缓存处理（新增cache-control）
    - 增加host字段、支持断点传输等

  #### HTTP2.0
    - 多路复用（单个TCP可以有多个文件）
    - 头部压缩（去掉一样的头部参数，只传输不一样的参数）
    - 二进制传输（传输数据改为二进制传输，安全，快）
    - 服务器推送（代码支持）

## HTTPS(HyperText Transfer Protocaol Secure，超文本传输安全协议)

  #### HTTPS = HTTP + SSL/TLS

  #### HTTPS验证过程

      简单解释

      - 客户端访问网站，服务器使用RSA生成公钥和私钥
      - 服务器把公钥发给客户端，私钥自己保存
      - 客户端使用服务器的公钥加密~~随机生成的密钥~~，发送给服务器，服务器使用私钥解密（非对称加密）
      - 利用随机生成的密钥跟服务加密传输数据（对称加密）

      详细解释

      - 浏览器将自己支持的一套加密规则发送给服务器
      - 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式返回给浏览器。证书包含了网站地址、加密公钥、证书的颁发机构。
      - 浏览器获得网站证书之后浏览器做以下工作：
            - 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示
            - 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密
            - 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站
      - 服务器接收客户端发来的数据之后会做以下操作：
            - 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致
            - 使用密码加密一段握手消息，发送给浏览器
      - 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密

## 三次握手与四次挥手

  三次握手与SSL加密顺序 =====> 先三次握手再TLS/SSL

  #### 三次握手
    1. 客户端发送SYN(SEQ=x)报文给服务器，进入SYN_SEND状态
    2. 服务端收到SYN报文，回应一个SYN(SEQ=y) ACK(ACK=x+1)报文，进入SYN_RECV状态
    3. 客户端收到服务端的SYN报文，回应一个ACK(ACK=y+1)报文，进入Established（已建立的）状态

    三次握手完成后，TCP客户端和服务端成功建立连接，可以开始传输数据了

    为什么握手是三次，而不是两次或四五次呢？
    1. 为什么是三次？阻止重复历史连接的初始化、同步双方的初始序列号、避免浪费资源
    2. 为什么不是四五次？其实也可以是四五次，只是三次更简洁，没那么繁琐

  #### 四次挥手（连接终止协议）
    1. 客户端发送一个FIN，用来关闭客户端到服务器的数据传送
    2. 服务器收到这个FIN，返回一个ACK(ACK=FIN+1)，确认序号为收到的序号加1。和SYN一样，一个FIN占用一个序号
    3. 服务器关闭客户端的连接，发送一个FIN给客户端
    4. 客户端发回ACK报文确认，并将确认序列号设置为收到序号加1

    为什么挥手需要四次？

    ```
    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
    但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。
    只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手
    ```

## 缓存
  #### 强制缓存
    1. 标识
      - Cache-Control
      - Expires
    2. 三级缓存原理
      - 先查找内存，如果内存存在，从内存中加载，Size栏显示from memory cache，状态码为200
      - 如果内存中没找到，选择硬盘缓存，如果硬盘中有，从硬盘中加载，Size栏显示from disk cache，状态码为200
      - 如果硬盘中没找到，那就进行网络请求，走协商缓存
      - 加载到的资源缓存到内存或硬盘中
    3. 文件缓存
      - 样式文件缓存到磁盘中，因为css样式加载一次即可渲染出页面
      - 脚本缓存到内存中，因为把脚本存在磁盘中，在执行时会把该脚本从磁盘中提取到缓存中来，这样的IO开销比较大，有可能会导致浏览器失去响应
    
  #### 协商缓存
    1. 标识
      - Last-Modified If-Modified-Since (http1.0)
      - Etag If-None-Match (http1.1)
    2. 原理
      - 对比相应字段，如果没有变化，返回304，从浏览器缓存中读取
      - 否则，返回200，传输新的资源
